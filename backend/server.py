# Correct modern imports would be:
from flask import Flask, request, jsonify
from langchain_core.prompts import PromptTemplate
from langchain_community.llms import HuggingFaceHub
from langchain.chains import LLMChain  # Not just 'langchain'
from langchain_google_genai import ChatGoogleGenerativeAI
from langchain.memory import ConversationBufferMemory  # Memory moved to core
from flask_cors import CORS

# Initialize the Flask app
app = Flask(__name__)
CORS(app)
# API Key and LLM Initialization
KEY = "AIzaSyBsTD9ZJXtUs_3ZtNfr6A6DwgWGIayeIF0"
llm = ChatGoogleGenerativeAI(api_key=KEY, model="gemini-1.5-pro", temperature=0.2)

# Memory Initialization
conversation_memory = ConversationBufferMemory(memory_key="chat_history", input_key="user_input", return_messages=True)

# Prompts
dish_suggestion_template = """
You are a friendly assistant. When the user expresses a craving or asks for something to eat, analyze the following input carefully:

User Input: {user_input}

If the user does not specify a cuisine, respond with *only one dish name* from Indian cuisine. If the user mentions a specific cuisine, then suggest *only one dish name* from that cuisine. Do not add any extra commentary, explanations, or formatting. 
Only provide the dish name.
"""
dish_suggestion_prompt = PromptTemplate(template=dish_suggestion_template, input_variables=["user_input"])

dish_name_extraction_template = """
You are an expert in extracting dish names from user and AI conversations. 
You will be provided with two inputs:

1. *Dish Suggestion Output*: {dish_suggestion_output} 
   - This is the response generated by the dish suggestion chain, which may contain various details.

Your task is to analyze dish suggestion output and extract the name of the dish. 
Store the extracted dish name in a variable called {dish_name} and send it as the output.

Make sure to provide only the dish name without any additional commentary or formatting.
"""
dish_name_extraction_prompt = PromptTemplate(template=dish_name_extraction_template, input_variables=["dish_suggestion_output"])

recipe_prompt_template = """
You are a professional chef. Your task is to provide a well-organized recipe based on the dish name extracted from the *dish_name_extraction_chain*.

The dish name will be given to you in the variable {dish_name}. Use it as the title of the recipe and provide relevant ingredients and instructions.

### Recipe Structure:

*Dish Name:* {dish_name}

*Ingredients:*  
- List all ingredients with exact quantities.

*Instructions:*  
1. Break down the recipe into simple, numbered steps.
2. Add cooking tips or tricks where appropriate to enhance the dish.
"""
recipe_prompt = PromptTemplate(template=recipe_prompt_template, input_variables=["dish_name"])

followup_prompt_template = """
You are an expert assistant, always ready to answer follow-up questions related to the current recipe or dish.

You will receive the following inputs:
1. *Dish Name*: Provided from the dish_name_extraction_chain as {dish_name}.
2. *Recipe*: The detailed recipe provided earlier in the interaction as {recipe}.
3. *User Input*: The follow-up question or query asked by the user, provided as {user_input}.

Use these inputs to:
- Suggest ingredient substitutions.
- Offer cooking tips, nutritional information, or serving suggestions.
- Adjust cooking times or storage recommendations based on user queries.

If the user's question is unrelated to the current dish or recipe, respond with:
"I’m here to help with recipe-related questions. Feel free to ask about cooking or the dish!"

Always refer to the specific dish name ({dish_name}) wherever appropriate to maintain context.
"""
followup_prompt = PromptTemplate(template=followup_prompt_template, input_variables=["dish_name", "user_input", "recipe"])

routing_template = """
Analyze the user's query: {user_input}

- If the query involves asking for a dish suggestion (e.g., craving, cuisine type, or explicit mention of a dish name), 
  return "dish_suggestion".
- If it asks for a recipe for a specific dish, return "recipe".
- If it’s a follow-up question related to a previously discussed dish or recipe, return "followup".

Respond with *only one word*: "dish_suggestion", "recipe", or "followup".
"""
routing_prompt = PromptTemplate(template=routing_template, input_variables=["user_input"])

# Initialize Chains
dish_suggestion_chain = LLMChain(prompt=dish_suggestion_prompt, llm=llm, output_key="dish_suggestion", memory=conversation_memory)
dish_name_extraction_chain = LLMChain(prompt=dish_name_extraction_prompt, llm=llm, output_key="dish_name", memory=conversation_memory)
recipe_chain = LLMChain(prompt=recipe_prompt, llm=llm, output_key="recipe", memory=conversation_memory)
followup_chain = LLMChain(prompt=followup_prompt, llm=llm, output_key="followup_response", memory=conversation_memory)
routing_chain = LLMChain(prompt=routing_prompt, llm=llm, output_key="route")

# Flask routes
@app.route("/chat", methods=["POST"])
def chat():
    user_input = request.json.get("user_input", "").strip()
    
    if not user_input:
        return jsonify({"error": "Invalid input"}), 400

    # Routing response using routing chain
    routing_response = routing_chain.invoke({"user_input": user_input})
    route = routing_response.get("route", "").strip()
    
    if route == "dish_suggestion":
        dish_suggestion_response = dish_suggestion_chain.invoke({"user_input": user_input})
        dish_suggestion = dish_suggestion_response.get("dish_suggestion", "").strip()
        return jsonify({"dish_suggestion": dish_suggestion})
        
    elif route == "recipe":
        dish_name_extraction_response = dish_name_extraction_chain.invoke({"dish_suggestion_output": dish_suggestion})
        dish_name = dish_name_extraction_response.get("dish_name", "").strip()
        
        if dish_name:
            recipe_response = recipe_chain.invoke({"dish_name": dish_name})
            recipe = recipe_response.get("recipe", "")
            return jsonify({"recipe": recipe})
        else:
            return jsonify({"error": "Dish name extraction failed."}), 500
    
    elif route == "followup":
        followup_response = followup_chain.invoke({
            "dish_name": dish_name,  
            "user_input": user_input,  
            "recipe": recipe
        })
        followup_text = followup_response.get("followup_response", "").strip()
        return jsonify({"followup_response": followup_text})
    
    else:
        return jsonify({"error": "Unknown route."}), 400

# Run the app
if __name__ == "__main__":
    app.run(debug=True)
